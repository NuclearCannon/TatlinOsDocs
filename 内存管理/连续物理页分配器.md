# 连续物理页分配器

在TrustOS的基础上，我们的TatlinOS设计了连续物理页分配器，以

## 原有设计的问题

在TrustOS中，物理页都是单独分配的，没有方法开辟两页连续的物理页。虽然大部分情况下也不需要连续物理页，但是virtio-drivers的硬件抽象层对此有要求，而TrustOS对此仅仅是连续申请多个物理页，并指望它们是连续的：

```rust
/// TrustOS中对virtio-drivers提供的硬件抽象层
fn dma_alloc(pages: usize) -> usize {
    let mut ppn_base = PhysPageNum(0);
    for i in 0..pages {
        let frame = frame_alloc().unwrap();
        if i == 0 {
            ppn_base = frame.ppn;
        }
        assert_eq!(frame.ppn.0, ppn_base.0 + i);
        QUEUE_FRAMES.lock().push(frame);
    }
    let pa: PhysAddr = ppn_base.into();
    pa.0
}
```

这显然非常不安全。为了解决这个问题，TatlinOS中设计了一个基于伙伴算法的连续物理页分配器：

```rust
...
use buddy_system_allocator::LockedHeap;
...
// ----------------CMA-------------------
// 基于伙伴算法的连续物理地址分配器
// 除了内核本身的各ELF段（堆在数据段里面）之外
// 其他所有的空闲空间均用伙伴算法管理
static CMA_ALLOCATOR: LockedHeap = LockedHeap::empty();

/// initiate heap allocator
pub fn init_cma() {
	...
}

/// 分配连续物理内存页（返回起始物理地址）
pub fn cma_alloc(pages: usize) -> Option<PhysAddr> {
    ...
}

/// 释放连续物理内存
pub fn cma_dealloc(paddr: PhysAddr, pages: usize) {
    ...
}

```

外界通过调用cma_alloc和cma_dealloc来动态申请和释放物理页，这样，如果外界出于一些特殊的目的想要连续的物理页，就可以从这里申请。

但是，考虑到大多数的请求是单页的申请和释放，每次都使用伙伴算法来分配可能会导致性能问题，TatlinOS还设计了一个`PAGE_CACHE`（位于`src/mm/page_cache.rs`），释放单页时总是先释放到`PAGE_CACHE`中，申请单页时优先从`PAGE_CACHE`中申请。如果`PAGE_CACHE`中的页过多或者过少，则会批量地使用伙伴算法分配器来申请或归还物理页。

同时，我们并没有丢弃TrustOS中原有的物理页帧（一个生命周期与物理页所有权绑定的类）`FrameTracker`，而是将其搭建在PAGE_CACHE的基础之上：

```rust
impl FrameTracker {
    fn new(ppn: PhysPageNum) -> Self {
        let bytes_array = ppn.bytes_array_mut();
        for i in bytes_array {
            *i = 0;
        }
        Self { ppn }
    }

    pub fn alloc() -> Option<Arc<FrameTracker>> {
        let ppn = PAGE_CACHE.alloc()?;
        let ret = Some(Arc::new(FrameTracker::new(ppn)));
        ret
    }
}

impl Debug for FrameTracker {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("FrameTracker:PPN={:#x}", self.ppn.0))
    }
}

impl Drop for FrameTracker {
    fn drop(&mut self) {
        PAGE_CACHE.dealloc(self.ppn);
    }
}

```

